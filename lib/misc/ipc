case $__script_lib_have_misc_ipc in
1)
	return 0
	;;
esac

case $SCRIPT_LIB_ROOT in
"")
	_libroot=/usr/share/scriptlib
	;;
*)
	_libroot=$SCRIPT_LIB_ROOT
	;;
esac

. ${_libroot}/string/err
. ${_libroot}/string/isctype
. ${_libroot}/misc/current_pid

#
# usage: IPC_INIT tmpdir [concurrency]
#
# tmpdir - a writeable directory for IPC_* functions to perform work in.
# concurrency - maximum child concurrency for this IPC_INIT()'ed group
#	of processes.  valid range is 1 - CHILD_MAX.  default is 1. 
#	if CHILD_MAX is non numeric, such as 'undefined',
#	the max defaults to 127.
#
# returns 0 on success (IPC safe to use)
# returns 1 on error (IPC not safe to use)
#
# IPC_INIT() performs preliminaries and sanity checks, and populates
# tmpdir with the required IPC hierarchy.  it is recommended that tmpdir
# not be used by anything else.
#
# IPC_INIT() will drop a file in tmpdir named ``info'' and source it
# automatically, thus setting the following parameters:
#
# IPC_RUNNING_DIR, IPC_PENDING_DIR, IPC_ENDED_DIR
#	subdirs of the given tmpdir, used for internal queue management.
#	the various IPC_*() functions drop pid-named files into these
#	directories during run time.  external programs can approximate
#	the number of children running by looking at these directories.
# IPC_MASTER
#	the pid of the process who called IPC_INIT.
# IPC_CONCURRENCY
#	the value of concurrency given to IPC_INIT.
#
# WARNING WWAARRNNIINNGG WARNING
# ------- ------- -------
#
# do not invoke IPC_INIT from within a command substitution (eg:
# ``if ! err=$(IPC_INIT "$tmpdir"); then echo $err; fi'').
# as this will taint the value current_pid() returns for IPC_MASTER.
# naturally, it is perfectly fine to invoke it without a command substitution
# (eg: ``if ! IPC_INIT "$tmpdir"; then error cleanup; fi'').
# NOTE: this situation is precisely why IPC_INIT() doesn't do something
# useful like emit the full path to the info file, which would open the door
# for nice situations like "IPC_INIT $(mktemp -d)" or the eval commonly seen
# with ssh-agent(1).  c'est la vie.
#
IPC_INIT()
{
	local funcname=IPC_INIT
	local usage="$funcname(): usage: $funcname() tmpdir [concurrency]"

	local default_child_max=127
	local default_concurrency=1

	local child_max concurrency
	local current_pid
	local pending_dir running_dir ended_dir
	local tmpdir

	# enforce a predictable sorting order critical for pathnames
	# later
	LC_ALL=C

	# file globbing must be active
	case $- in
	*f*)
		warn EPERM "$funcname(): 'noglob' must be unset"
		return 1
	esac

	tmpdir=$1
	if [ -z "$tmpdir" ]; then
		warn EINVAL "$funcname(): null tmpdir"
		warnx "$usage"
		return 1
	fi
	if [ ! -d "$tmpdir" ]; then
		warn ENOTDIR "$funcname(): tmpdir: '$tmpdir'"
		warnx "$usage"
		return 1
	fi
	if [ ! -w "$tmpdir" ]; then
		warn EACCES "$funcname(): tmpdir: '$tmpdir'"
		return 1
	fi

	concurrency=$2
	if [ -z "$concurrency" ]; then
		concurrency=$default_concurrency
	fi
	if ! isdigit "$concurrency"; then
		warn EINVAL "$funcname(): concurrency: '$concurrency'"
		return 1
	fi
	if ! child_max=$(getconf CHILD_MAX); then
		warnx "$funcname(): failed to check getconf(1)"
		return 1
	fi
	if ! isdigit "$child_max"; then
		child_max=$default_child_max
	fi
	if [ $concurrency -gt $child_max ]; then
		warnx "$funcname(): limiting concurrency: '$concurrency' to CHILD_MAX: '$child_max'"
		concurrency=$child_max
	fi

	if ! current_pid=$(current_pid); then
		warnx "$funcname(): failed current_pid()"
		return 1
	fi

	if [ -e "$tmpdir/info" ]; then
		warnx "$funcname(): stale tmpdir: '$tmpdir', already has info file"
		return 1
	fi

	pending_dir="$tmpdir/pending"
	running_dir="$tmpdir/running"
	ended_dir="$tmpdir/ended"
	if ! mkdir -- "$pending_dir" "$running_dir" "$ended_dir"; then
		warnx "$funcname(): failed to populate tmpdir: '$tmpdir'"
		return 1
	fi

	# drop the info file down
	cat > "$tmpdir/info" <<- EOT
		readonly IPC_PENDING_DIR=$pending_dir
		readonly IPC_RUNNING_DIR=$running_dir
		readonly IPC_ENDED_DIR=$ended_dir
		readonly IPC_MASTER=$current_pid
		readonly IPC_CONCURRENCY=$concurrency
		export IPC_PENDING_DIR IPC_RUNNING_DIR IPC_ENDED_DIR
		export IPC_MASTER IPC_CONCURRENCY
	EOT

	case $BASH_VERSION in
	"")
		;;
	*)
		shopt -s expand_aliases
		;;
	esac

	. "$tmpdir/info"
	return 0
}

IPC2_START()
{
	local funcname=IPC2_START
	local usage="$funcname(): usage: $funcname() tmpdir [concurrency]"

	local default_child_max=127
	local default_concurrency=1

	local child_lock
	local child_max
	local concurrency
	local fifo
	local tmpdir

	tmpdir=$1
	if [ -z "$tmpdir" ]; then
		warn EINVAL "$funcname(): null tmpdir"
		warnx "$usage"
		return 1
	fi
	if [ ! -d "$tmpdir" ]; then
		warn ENOTDIR "$funcname(): tmpdir: '$tmpdir'"
		warnx "$usage"
		return 1
	fi
	if [ ! -w "$tmpdir" ]; then
		warn EACCES "$funcname(): tmpdir: '$tmpdir'"
		return 1
	fi

	concurrency=$2
	if [ -z "$concurrency" ]; then
		concurrency=$default_concurrency
	fi
	if ! isdigit "$concurrency"; then
		warn EINVAL "$funcname(): concurrency: '$concurrency'"
		return 1
	fi
	if ! child_max=$(getconf CHILD_MAX); then
		warnx "$funcname(): failed to check getconf(1)"
		return 1
	fi
	if ! isdigit "$child_max"; then
		child_max=$default_child_max
	fi
	if [ $concurrency -gt $child_max ]; then
		warnx "$funcname(): limiting concurrency: '$concurrency' to CHILD_MAX: '$child_max'"
		concurrency=$child_max
	fi

	if [ -e "$tmpdir/info" ]; then
		warnx "$funcname(): stale tmpdir: '$tmpdir', already has info file"
		return 1
	fi

	fifo="$tmpdir/fifo"
	if ! mkfifo -- "$fifo"; then
		warnx "$funcname(): failed to populate tmpdir: '$tmpdir'"
		return 1
	fi

	child_lock="$tmpdir/child_lock"
	if ! touch "$child_lock"; then
		warnx "$funcname(): failed to set \$child_lock: '$child_lock'"
		return 1
	fi
	if ! chmod 0000 "$child_lock"; then
		warnx "$funcname(): failed to write-protect \$child_lock: '$child_lock'"
		return 1
	fi
	# drop the info file down
	cat > "$tmpdir/info" <<- EOT
		readonly IPC_FIFO=$fifo
		export IPC_FIFO
		readonly IPC_CHILD_LOCK=$child_lock
		export IPC_CHILD_LOCK
		readonly IPC_CONCURRENCY=$concurrency
		export IPC_CONCURRENCY
		readonly IPC_TEARDOWN=$tmpdir/teardown
		export IPC_TEARDOWN
	EOT

	case $BASH_VERSION in
	"")
		;;
	*)
		shopt -s expand_aliases
		;;
	esac

	. "$tmpdir/info"

	IPC2_MASTER &

	return 0
}

IPC2_MASTER()
{
	local funcname=IPC2_MASTER

	local currently_running=0
	local currently_pending=0
	local currently_signaled=0
	local currently_unsignaled=0
	local lifetime_ended_total=0
	local lifetime_started_total=0
	local message=INIT
	local pending_queue _pending_queue
	local pid pids
	local rogue_pid=1
	local signal=CONT
	local signaled_queue _signaled_queue
	local teardown=0
	local unsignaled_queue _unsignaled_queue
	local var var2
	local wait_requestors _wait_requestors

	if ! pid=$(current_pid); then
		warnx "$funcname(): failed to get current PID"
		return 1
	fi
	debug 1 "$funcname(): [$message] -> '$pid'"

	while :; do

		message=READ
		debug 1 "$funcname(): [$message] beginning to read fifo"
		while read pid message; do

			while :; do

				debug 1 "$funcname(): [READ] fifo: '$pid' -> [$message]"
				debug 13 "$funcname(): [$message] logging message from '$pid'"
				# echo "$pid $message $funcname" >>"ipcdir/recvlog"

				case $message in
				"END "*[0-9]*)
					currently_running=$(( currently_running - 1 ))
					lifetime_ended_total=$(( lifetime_ended_total + 1 ))
					var=${message##* } # return value of the payload
					message=${message% $var}
					if [ $var -ne 0 ]; then
						warnx "$funcname(): [$message] nonzero return value '$var' from \$pid: '$pid'"
					fi
					;;
				FINISH)
					# FINISH is the IPC2_END version of IPC2_CHILD's START.
					# it is used to indicate a SIGSTOP'd IPC2_END process
					# has received its SIGCONT.
					rogue_pid=1
					_wait_requestors=""
					debug 3 "$funcname(): [$message] removing \$pid '$pid' from \$wait_requestors '$wait_requestors'"
					for var in $wait_requestors; do
						# remove the incoming PID from the wait requestors list
						# by making a new list populated by all the
						# pids in $wait_requestors other than the one we have
						# in our hand now.
						case $var in
						$pid)
							rogue_pid=0
							;;
						*)
							case $_wait_requestors in
							"")
								_wait_requestors=$var
								;;
							*)
								_wait_requestors="$_wait_requestors $var"
								;;
							esac
							;;
						esac
					done
					if [ $rogue_pid -eq 1 ]; then
						# received a message for a non-pending PID.
						# XXX: ignore this?  fail?
						warnx "$funcname(): [$message] received message for unknown wait requestor \$pid: '$pid'"
						return 1
					fi
					wait_requestors="$_wait_requestors"
					debug 3 "$funcname(): [$message] \$wait_requestors is now '$wait_requestors', ensure removal of \$pid: '$pid'"
					;;
				PENDING)
					# at the pending stage, the PID is the same as IPC_CHILD's caller
					# so caring about it is not of significant value.
					# but we can still keep track of them as unique instances.
					currently_pending=$(( currently_pending + 1 ))
					;;
				"RENAME "*[0-9]*)
					_signaled_queue=""
					# remove '$pid' from signaled queue and replace with the
					# new pid, derived from '$message'
					var2=${message##* }
					for var in $signaled_queue; do
						case $var in
						$pid)
							# rename me
							var=$var2
							;;
						esac
						if [ -z "$_signaled_queue" ]; then
							_signaled_queue=$var
						else
							_signaled_queue="$_signaled_queue $var"
						fi
					done
					;;
				START)
					currently_running=$(( currently_running + 1 ))
					currently_signaled=$(( currently_signaled - 1 ))
					lifetime_started_total=$(( lifetime_started_total + 1 ))
					;;
				WAIT)
					# - any children already in the $signaled_queue have already
					# been sent their SIGCONT and already count toward the
					# running total, so they will continue to be sent SIGCONT
					# in fell swoops during teardown mode.
					# - otherwise, the $unsignaled_queue now can be thought of
					# as a kill_queue.
					signal=KILL
					teardown=1
					if ! >"$IPC_TEARDOWN"; then
						warnx "$funcname(): [$message] failed to set \$IPC_TEARDOWN file: '$IPC_TEARDOWN'"
					fi
					debug 3 "$funcname(): [$message] adding \$pid '$pid' to \$wait_requestors '$wait_requestors'"
					# XXX check for dupes?
					if [ -z "$wait_requestors" ]; then
						wait_requestors=$pid
					else
						wait_requestors="$wait_requestors $pid"
					fi
					debug 4 "$funcname(): [$message] \$wait_requestors is now '$wait_requestors', ensure addition \$pid: '$pid'"
					;;
				*)
					warnx "$funcname(): [$message] ERROR: unknown message"
					return 1
					;;
				esac

				message=WORK
				debug 2 "$funcname(): [$message] looking for work"
				if [ $teardown -eq 1 ]; then
					debug 0 "$funcname(): [$message] teardown mode confirmed"
					
					if [ $currently_running -gt 0 ]; then
						# still more running children to wait for
						debug 2 "$funcname(): [$message] \$currently_running -gt 0, need to wait"
						break
					else
						debug 2 "$funcname(): [$message] no running \$currently_running to wait for"
					fi

					if [ $currently_signaled -gt 0 ]; then
						debug 2 "$funcname(): [$message] \$currently_running -gt 0, need to wait"
						break
					else
						debug 2 "$funcname(): [$message] no running \$currently_signaled to wait for"
					fi

					debug 2 "$funcname(): [$message] holy shit we are done! @&@ &@ &@& @& @&&@&@ @"
					# all done!
					break 3
				fi

				if [ $currently_running -ge $IPC_CONCURRENCY ]; then
					debug 2 "$funcname(): [$message] at concurrency limit: '$IPC_CONCURRENCY', looping"
					break
				fi

				if [ $currently_pending -eq 0 ]; then
					break
				fi

				if [ -e "$IPC_CHILD_LOCK" ]; then
					debug 37 "$funcname(): [$message] attempting to remove child lock: '$IPC_CHILD_LOCK'"
					if ! rm -f "$IPC_CHILD_LOCK"; then
						warnx "$funcname(): [$message] unable to remove pending child lock: '$IPC_CHILD_LOCK'"
						return 1
					fi
					currently_pending=$(( currently_pending - 1 ))
					currently_signaled=$(( currently_signaled + 1 ))
				else
					debug 2 "$funcname(): [$message] no child lock found"
				fi

				break
			done # while :;

			message=STATS
			debug 10 "$funcname(): [$message] \$currently_running: '$currently_running'"
			debug 12 "$funcname(): [$message] \$lifetime_started_total: '$lifetime_started_total'"
			debug 12 "$funcname(): [$message] \$lifetime_ended_total: '$lifetime_ended_total'"

			message=READ
			debug 1 "$funcname(): [$message] reading fifo"
			continue 

		done <"$IPC_FIFO"

		message=RECOVER
		debug 7 "$funcname(): [$message] fell out of the loop because no pending fifo writes to read"
		debug 10 "$funcname(): [$message] \$currently_running: '$currently_running'"
		debug 12 "$funcname(): [$message] \$lifetime_started_total: '$lifetime_started_total'"
		debug 12 "$funcname(): [$message] \$lifetime_ended_total: '$lifetime_ended_total'"
		
		if [ $currently_running -gt 0 ]; then
			debug 7 "$funcname(): [$message] still children running"
			continue
		fi
		if [ $currently_signaled -gt 0 ]; then
			debug 7 "$funcname(): [$message] still children signaled"
			continue
		fi
		if [ $lifetime_started_total -ne $lifetime_ended_total ]; then
			debug 7 "$funcname(): [$mismatch] in lifetime total!?"
			continue
		fi

		continue

	done # while :; # top level

	message=COMPLETE
	if [ ! -z "$wait_requestors" ]; then
		debug 2 "$funcname(): [$message] outstanding \$wait_requestors found"
		kill -CONT $wait_requestors
		debug 2 "$funcname(): [$message] sent SIGCONT to \$wait_requestors: '$wait_requestors'"
	fi

	debug 10 "$funcname(): [$message] \$currently_running: '$currently_running'"
	debug 12 "$funcname(): [$message] \$lifetime_started_total: '$lifetime_started_total'"
	debug 12 "$funcname(): [$message] \$lifetime_ended_total: '$lifetime_ended_total'"
	debug 1 "$funcname(): [$message] total victory, shutting down"
	return 0
}

IPC2_END()
{
	local funcname=IPC2_END
	local message=WAIT
	local pid

	# force a subshell so we can stop our own instantiation
	# without otherwise stopping the whole script.
	# but don't background it; this function should block
	# until acknowledged by the master
	
	(
		if ! pid=$(current_pid); then
			warnx "$funcname(): [$message] failed current_pid(), this child is worthless"
			return 1
		fi

		debug 13 "$funcname(): [$message] -> '$pid'"
		debug 12 "$funcname(): [$pid] [$message] sending message to fifo"
		if ! echo "$pid $message" >>"$IPC_FIFO"; then
			warnx "$funcname(): [$pid] [$message] failed sending message"
			return 1
		fi
		debug 13 "$funcname(): [$pid] [$message] logging message"
		## echo "$pid $message $funcname" >>"ipcdir/sendlog"
		debug 8 "$funcname(): [$pid] [$message] pausing myself with SIGSTOP"
		kill -STOP "$pid"
	);

	return 0
} 
IPC2_CHILD()
{
	local funcname=IPC2_CHILD
	local message pid
	local oldumask
	local retval
	local umask=0777

	# in the current implementation this is effectively the same as '$$' but
	# i'll burn another current_pid() run and we'll see if it hurts perf at all
	if ! pid=$(current_pid); then
		warnx "$funcname(): failed current_pid()"
		return 1
	fi
	if ! oldumask=$(umask); then
		warnx "$funcname(): [$message] failed to determine current umask"
		return 1
	fi
	message=PENDING
	debug 14 "$funcname(): [$pid] [$message] 1: sending message to fifo"
	echo "$pid $message" >>"$IPC_FIFO"
	debug 14 "$funcname(): [$pid] [$message] 2: unblocked from fifo"
	debug 16 "$funcname(): [$pid] [$message] 3: adding message to log"
	# echo "$pid $message $funcname '$@'" >>"ipcdir/sendlog"
	if ! umask "$umask"; then
		warnx "$funcname(): [$message] failed to modify umask to '$umask'"
		return 1
	fi

	until 2>/dev/null >"$IPC_CHILD_LOCK"; do
		if [ -e "$IPC_TEARDOWN" ]; then
			debug 2 "$funcname(): [$message] saw teardown semaphore, returning"
			return 1
		fi
	done
	debug 13 "$funcname(): [$message] Y: free from child lock"
	if ! umask "$oldumask"; then
		warnx "$funcname(): [$message] failed to reset umask to \$oldumask: '$oldumask'"
		return 1
	fi
	message=START
	{
		if ! pid=$(current_pid); then
			warnx "$funcname(): failed current_pid(), child now worthless"
			return 1
		fi

		debug 14 "$funcname(): [$pid] [$message]"
		while :; do

			# same block as above
			debug 14 "$funcname(): [$pid] [$message] 1: sending message to fifo"
			case $message in
			END)
				echo "$pid $message $retval" >>"$IPC_FIFO"
				;;
			*)
				echo "$pid $message" >>"$IPC_FIFO"
				;;
			esac

			debug 14 "$funcname(): [$pid] [$message] 2: unblocked from fifo"
			debug 16 "$funcname(): [$pid] [$message] 3: adding message to log"
			# echo "$pid $message $funcname '$@'" >>"ipcdir/sendlog"

			case $message in
			START)
				debug 11 "$funcname(): [$pid] [$message] 4: executing workload '$@'"
				if eval "$@"; then
					retval=$?
					debug 11 "$funcname(): [$pid] [$message] 5: finished workload '$@'"
				else
					retval=$?
					warnx "$funcname(): [$pid] [$message]: workload failed: '$@'"
				fi
				message=END
				;;
			END)
				break
				;;
			*)
				warnx "$funcname(): [$pid] [$pid]: unknown \$message: '$message'"
				return 1
			esac
		done
	}&

	return 0
}

#
# usage: IPC_KILL
#
# individually checks $IPC_PENDING_DIR and $IPC_RUNNING_DIR for any pid
# files, sends a kill to everything it finds in there.
#
# TODO: refresh my memory on how the files move from one dir to another and
#       get unlinked when a process is totally done/reaped
#
# returns 0 on success
# returns 1 on error
#
IPC_KILL()
{
	local funcname=IPC_KILL
	local usage="$funcname(): usage: $funcname"

	local canary
	local dir
	local kill_list

	# child files are PIDs with an underscore prefix representing how
	# many generations deep the child is.
	local child
	
	while :; do
		canary=0

		for dir in $IPC_PENDING_DIR $IPC_RUNNING_DIR; do

			kill_list=

			if [ -z "$dir" ]; then
				warnx "$funcname(): null directory given"
				return 1
			fi
			if [ ! -d "$dir" ]; then
				warn ENOTDIR "$funcname(): '$dir'"
				continue
			fi

			for child in "$dir/"*; do
				case $child in
				*"*")
					# no files in the dir to glob
					debug 2 "$funcname(): found a bare *: '$child'; empty '$dir'?"
					continue 2
					;;
				esac
				child=${child##*/} # basename

				# chop off leading child depth markers
				# for now, we can eliminate them entirely, but eventually
				# we'll have to consider their length to translate that to
				# depth away from parent.
				case $child in
				_*)
					child=${child##*_}
					debug 2 "$funcname(): chopped '_' off \$child: '$child'"
					;;
				esac

				case $child in
				$IPC_MASTER)
					warnx "$funcname(): \$IPC_MASTER seen in '$dir'"
					# XXX: should not happen?
					return 1
					;;
				esac

				# this is a number test instead of a -z against the string
				# as the latter is slower as the length of the string grows
				case ${#kill_list} in
				0)
					kill_list=$child
					;;
				*)
					# prepending to the list ensures children with
					# highest generational depth are first
					kill_list="$child $kill_list"
					;;
				esac
				debug 2 "$funcname(): \$kill_list: '$kill_list'"
			done

			if [ -z "$kill_list" ]; then
				continue
			fi
			canary=$(( canary | 1 ))
			kill $kill_list || true
		done

		if [ $canary -gt 0 ]; then
			# work was done in at least one of the pending/running dirs
			continue
		fi
		break
	done

	return 0
}

#
# usage: IPC_FORK commandline to fork
#
# if we are not at the limit of concurrency, forks a new child.
# otherwise, it will manage the currently forked children until
# some headroom appears, at which point the new child will be forked.
#
# returns 0 on success
# returns 1 on error
#
# IPC_FORK calls one of two helper functions based on whether
# or not it is being run by the $IPC_MASTER.  reason for this
# distinction is that process oversight IPC_FORK is also responsible for sending
# the process oversight
#
# note, if you are running IPC_FORK from within forked children,
# you *will* deadlock if concurrency is less than the maximum
# number of potentially unstarted pending child-forked children
# out there.  eg, *really* don't leave it at the defaut of '1' in
# this case.
#
# XXX WARNING:
#
# backgrounding children from children is currently VERY DANGEROUS.
# it *functions*, but you need to specify a concurrency WAY HIGHER
# than you otherwise think you should.  it is strongly recommended
# to NOT background children from children at the present time
#
IPC_FORK()
{
	local funcname=IPC_FORK
	local p x
	if [ -z "$IPC_MASTER" ]; then
		warnx "$funcname(): \$IPC_MASTER is null"
		return 1
	fi
	if ! p=$(current_pid "$IPC_MASTER"); then
		warnx "$funcname(): failed current_pid()"
		return 1
	fi
	debug 1 "$funcname(): \$p is: '$p'"
	case $p in
	$IPC_MASTER)
		debug 2 "$funcname(): shall fork _ipc_master"
		if ! _ipc_master "$*"; then
			warnx "$funcname(): failed _ipc_master()"
			return 1
		fi
		;;
	*)
		x=0
		while :; do
			case $p in
			_*)
				p=${p#_}
				x=$(( $x + 1 ))
				;;
			*)
				break
				;;
			esac
		done
		debug 1 "$funcname(): \$p: '$p'; shall fork _ipc_child $x"
		if ! _ipc_child "$x" "$*"; then
			warnx "$funcname(): failed _ipc_child()"
			return 1
		fi
		;;
	esac
	return 0
}

#
# usage: IPC_FLUSH
#
# loops through _ipc_start and _ipc_end until they both did nothing $max times.
#
# $max is 16 by default, based on seeing things work just fine at 8 and then
# doubling it for safety's sake
#
# XXX check to see if current_pid is actually $IPC_MASTER
#
IPC_FLUSH()
{
	local funcname=IPC_FLUSH
	local e r s t	# ending, running, started, total
	local i		# current iteration of t being -eq 0
	local max=8
	while :; do
		if ! e=$(_ipc_end); then
			warnx "$funcname(): failed _ipc_end"
			return 1
		fi
		if ! s=$(_ipc_start); then
			warnx "$funcname(): failed _ipc_start"
			return 1
		fi
		if ! r=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR"
			return 1
		fi
		t=$(( $s + $e + $r ))
		if [ $t -eq 0 ]; then
			i=$(( $i + 1 ))
		else
			i=0
		fi
		if [ $i -gt $max ]; then
			warnx "$funcname(): \$i -gt \$max"
			break
		fi
	done
	return 0
}

#
# usage: IPC_START
#
# use at the start of all child processes/functions which are IPC_FORK()'d.
#
# for example:
#
# 	somefunc()
# 	{
# 		local var=b
# 		code
# 		return 0
#	}
#
# becomes:
#
# 	somefunc()
# 	{
# 		IPC_START
# 		local var=b
# 		code
# 		IPC_RETURN 0
# 	{
#
# creates local variables to contain pid, creates trap handler
# for use in signalling, and drops the current pid into the $IPC_PENDING_DIR.
# upon receipt of start signal, moves current pid from $IPC_PENDING_DIR to
# $IPC_RUNNING_DIR.
#
alias IPC_START='
	if [ -z "$IPC_MASTER" ]; then
		warnx "$funcname():[IPC_START] \$IPC_MASTER null"
		warnx "$funcname():[IPC_START] concurrency control disabled"
	else
		local _ipc_pid _ipc_loop_stop=0
		trap '\''trap - CONT; _ipc_loop_stop=1'\'' CONT
		if ! _ipc_pid=$(current_pid "$IPC_MASTER"); then
			warnx "$funcname()[IPC_START]: failed current_pid()"
			return 1
		fi
		if [ ! -d "$IPC_PENDING_DIR" ]; then
			warnx "$funcname()[IPC_START][$_ipc_pid]: pending dir not exist or not a directory"
			return 1
		fi
		if [ ! -d "$IPC_RUNNING_DIR" ]; then
			warnx "$funcname()[IPC_START][$_ipc_pid]: running dir not exist or not a directory"
			return 1
		fi
		> "$IPC_PENDING_DIR/$_ipc_pid"
		while [ $_ipc_loop_stop -eq 0 ]; do
			sleep 0.1
		done
		# strip off leading underscores during mv(1)
		mv -- "$IPC_PENDING_DIR/$_ipc_pid" "$IPC_RUNNING_DIR/${_ipc_pid##*_}"
	fi'

#
# usage: IPC_RETURN [retval]
#
# use in place of 'return' (for all instances!) inside all child processes/
# functions which are IPC_FORK()'d.
#
# see IPC_START above for an example usage.
#
# adds the current pid to the $IPC_ENDED_DIR and then returns whatever value
# was specfied.  if no value specified, the effect is the same as invoking
# a regular 'return' without args.
#
alias IPC_RETURN='
	if [ -z "$IPC_MASTER" ]; then
		warnx "$funcname():[IPC_RETURN][$_ipc_pid] \$IPC_MASTER null"
		warnx "$funcname():[IPC_RETURN][$_ipc_pid] concurrency control disabled"
		return 1
	else
		if [ ! -d "$IPC_ENDED_DIR" ]; then
			warnx "$funcname():[IPC_RETURN][$_ipc_pid] no \$IPC_ENDED_DIR"
			return 1
		fi
		> "$IPC_ENDED_DIR/$_ipc_pid"
	fi
	return' # leave the closing apostrophe on this line

#
# _ipc_getnumchildren dir
#
# emits the number of children in $dir.
#
# returns 0 on successful check
# returns 1 on error
#
_ipc_getnumchildren()
{
	local funcname=_ipc_getnumchildren
	local f n=0
	local usage="$funcname(): usage: $funcname dir"
	if [ -z "$1" ]; then
		warn EINVAL
		warnx "$usage"
		return 1
	fi
	for f in "$1"/*; do
		n=$(( $n + 1 ))
	done
	case $f in
	*"*")
		echo 0
		;;
	*)
		echo $n
		;;
	esac
	return 0
}

#
# _ipc_clean_ended
#
# emits the number of children it cleaned up (may be 0) and returns 0
# returns 1 on error
#
_ipc_clean_ended()
{
	local funcname=_ipc_clean_ended
	local usage="$funcname(): usage: $funcname"
	local ef rf rm
	local x=0
	for ef in $IPC_ENDED_DIR/*; do
		case $ef in
		"$IPC_ENDED_DIR/*")
			break
			;;
		esac
		rf=$IPC_RUNNING_DIR/${ef##*/}
		if [ ! -f "$rf" ]; then
			warnx "$funcname() \${ef##*/}: '${ef##*/}' exists in ended but not running"
			return 1
		fi
		case ${#rm} in
		0)
			rm="$ef $rf"
			;;
		*)
			rm="$ef $rf $rm"
			;;
		esac
		debug 2 "$funcname(): \$rm: '$rm'"
		x=$(( $x + 1 ))
	done
	if [ $x -gt 0 ]; then
		if ! rm -- $rm; then
			return 1
		fi
	fi
	echo $x
	return 0
}

#
# _ipc_start_n_children n
#
# starts up to $n children from the $IPC_PENDING_DIR by sending them all SIGCONT
# to break them out of IPC_START.
#
# returns 1 on error
# returns 0 otherwise and emits # of children it sent SIGCONT to
#
# XXX really should take ARG_MAX into account
#
_ipc_start_n_children()
{
	local funcname=_ipc_start_n_children
	local usage="$funcname(): usage: $funcname n"
	local n=$1 c s=0 k s
	local string
	case $n in
	"" | *[!0-9]*)
		warnx "$funcname(): non numeric \$n"
		warnx "$usage"
		return 1
		;;
	esac

	#
	# we will be getting a listing of the directory
	# in an order that, while correct, is the inverse
	# of what we want.  due to the underscore prefixes,
	# the following list will occur in closest-child-
	# first" order.  we want to SIGCONT the children in
	# farthest-child-first.  we also want to SIGCONT
	# only the $n children we were told.  the cost of
	# calling to the userland is too great here, so it is
	# much cheaper to take the output and use a param to
	# flip its order than it is to do a single $(ls -r).
	#
	for c in "$IPC_PENDING_DIR/"*; do
		case $c in
		*"*")
			echo 0
			return 0
			;;
		esac

		# chop off leading child depth markers
		c=${c#$IPC_PENDING_DIR/}
		while :; do
			case $c in
			_*)
				c=${c##*_}
				continue
				;;
			esac

			break
		done

		case $c in
			$IPC_MASTER)
			warnx "$funcname(): \$IPC_MASTER seen in \$IPC_PENDING_DIR"
			return 1
			;;
		esac

		# we can afford to be messy and not
		# worry about the extra space that
		# blindly doing string="$c $string" 
		# earns on the first time around.
		string="$c $string"

	done

	# build up kill string up to $n items
	for c in $string; do
		if [ $s -ge $n ]; then
			break
		fi

		case ${#k} in
		0)
			k=$c
			;;
		*)
			k="$c $k"
			;;
		esac

		s=$(( $s + 1 ))
	done

	if [ $s -gt 0 ]; then
		if ! kill -CONT $k; then
			return 1
		fi
	fi
	echo $s
	return 0
}

#
# _ipc_start 
#
# runs _ipc_start_n_children() with an argument that is the lesser of either
# the number pending children or the difference between $IPC_CONCURRENCY and
# what it finds to be running 
#
# returns 1 on error
# returns 0 on success and emits number of children it thinks it
#           started.  emits '-1' to indicate that we are already
#	    at max IPC_CONCURRENCY and no attempt to start children was made.
#
_ipc_start()
{
	local funcname=_ipc_start
	local r p headroom s
	if ! r=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
		warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR: '$IPC_RUNNING_DIR'"
		return 1
	fi
	headroom=$(( $IPC_CONCURRENCY - $r ))
	#
	# if we are at max already, indicate that to the caller
	#
	if [ $headroom -le 0 ]; then
		echo -1
		return 0
	fi
	if ! p=$(_ipc_getnumchildren "$IPC_PENDING_DIR"); then
		warnx "$funcname(): failed _ipc_getnumchildren \$IPC_PENDING_DIR: '$IPC_PENDING_DIR'"
		return 1
	fi
	if [ $p -eq 0 ]; then
		# no pending children
		echo 0
		return 0
	fi
	# don't start more than $headroom
	if [ $p -gt $headroom ]; then
		p=$headroom
	fi
	if ! s=$(_ipc_start_n_children "$p"); then
		warnx "$funcname(): failed _ipc_start_n_children() '$p'"
		return 1
	fi
	echo $s
	return 0
}

#
# usage: _ipc_end
#
# runs _ipc_clean_ended() until it reports no children
# were cleaned, then emits the total number of children it cleaned up.
#
_ipc_end()
{
	local funcname=_ipc_end
	local t=0 x
	#
	# this loop will run until there are no children in the
	# $IPC_ENDED_DIR.  at the end of the loop, '$ended' will be
	# however many children we cleaned up during looping
	#
	while :; do
		if ! x=$(_ipc_clean_ended); then
			warnx "$funcname(): failed _ipc_clean_ended()"
			return 1
		fi
		if [ $x -eq 0 ]; then
			break
		fi
		t=$(( $t + $x ))
	done
	echo $t
	return 0
}

#
# usage: _ipc_master
#
# invoked by IPC_FORK if IPC_FORK was called from the $IPC_MASTER pid.
#
_ipc_master()
{
	local funcname=_ipc_master
	local r1 r2 r c t
	while :; do
		debug 2 "$funcname(): trying _ipc_end()"
		if ! c=$(_ipc_end); then
			warnx "$funcname(): failed _ipc_end()"
			return 1
		fi
		r1=0
		if ! r1=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR"
			return 1
		fi
		if ! c=$(_ipc_start); then
			warnx "$funcname(): failed _ipc_start"
			return 1
		fi
		if [ $c -eq -1 ]; then
			debug 2 "$funcname(): already at max concurrency"
			continue
		fi
		if [ $c -ge $IPC_CONCURRENCY ]; then
			# we just think we started $IPC_CONCURRENCY's worth of
			# children, so chill out
			debug 2 "$funcname(): just started \$IPC_CONCURRENCY's worth"
			continue
		fi
		r2=0
		if ! r2=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR"
			return 1
		fi
		if [ $r1 -gt $r2 ]; then
			r=$r1
		else
			r=$r2
		fi
		t=$(( $c + $r ))

		# if we are at maximum, we need to
		# loop back to the top and look for more ended children
		if [ $t -ge $IPC_CONCURRENCY ]; then
			continue
		fi
		debug 2 "$funcname(): eval: '$*'"
		eval "$*" &
		break
	done
	return 0
}

#
# usage: _ipc_child current_pid
#
# invoked by IPC_FORK if IPC_FORK was not called from the $IPC_MASTER pid.
#
# inspects $IPC_RUNNING_DIR and $IPC_PENDING_DIR, compares against
# $IPC_CONCURRENCY; sleeps if too many running, otherwise evals the
# child with '&'.
#
# doesn't send any signals 
#
# RETURN
# 0 - evaled a child
# 1 - failed _ipc_getnumchildren()
#
_ipc_child()
{
	local funcname=_ipc_child
	local depth
	local r p headroom
	depth=$1
	shift
	while :; do
		if ! r=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR"
			return 1
		fi
		if ! p=$(_ipc_getnumchildren "$IPC_PENDING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_PENDING_DIR"
			return 1
		fi
		headroom=$(( $IPC_CONCURRENCY + $depth - $r - $p ))
		debug 2 "$funcname(): \$headroom: '$headroom'"
		if [ $headroom -le 0 ]; then
			# penalty sleep, not allowed to start yet
			sleep 0.1
			continue
		fi
		eval "$*" &
		break
	done
	return 0
}

__script_lib_have_misc_ipc=1
