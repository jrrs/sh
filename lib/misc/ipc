case $__script_lib_have_misc_ipc in
1)
	return 0
	;;
esac

case $SCRIPT_LIB_ROOT in
"")
	_libroot=/usr/share/scriptlib
	;;
*)
	_libroot=$SCRIPT_LIB_ROOT
	;;
esac

. ${_libroot}/string/err
. ${_libroot}/string/isctype
. ${_libroot}/misc/current_pid

#
# library usage:
#
# 1) anywhere before the code in question run IPC_START once.
# 2) sprinkle IPC_CHILD whereever you want to
# 3) run IPC_STOP when you want to tear things down or otherwise
#    need to wait for all the children to finish.
#

#
# usage: IPC_START tmpdir [concurrency]
#
# tmpdir - a writeable directory for IPC_* functions to perform work in.
# concurrency - maximum child concurrency for this IPC_START()'ed group
#	of processes.  valid range is 1 - CHILD_MAX.  default is 1. 
#	if CHILD_MAX is non numeric, such as 'undefined',
#	the max defaults to 127.
#
# returns 0 on success (IPC safe to use)
# returns 1 on error (IPC not safe to use)
#
# 1) IPC_START() performs preliminaries and sanity checks, and populates
#    tmpdir with the required IPC hierarchy.  it is recommended that tmpdir
#    not be used by anything else.
#
# 2) IPC_START() will drop a file in tmpdir named ``info'' and source it
#    automatically, thus setting the following parameters:
#
# IPC_CONCURRENCY
#	the value of concurrency given to or determined by IPC_START.
# IPC_FIFO
#       full path to the IPC fifo.  reading from this by processes
#	other than 
# IPC_CHILD_LOCK
#       a mode 0000 file used as the semaphore to control telling an
#	IPC_CHILD to proceed (i.e. we're below $IPC_CONCURRENCY)
# IPC_TEARDOWN
#	full path to the file used to signal (by invoking IPC_STOP)
#	that all pending unapproved children shall be terminated.
#	IPC_CHILD children who were previously approved are allowed
#	to continue running naturally.
#
# 3) lastly, IPC_START() will spawn the IPC_MASTER() process which
#    is responsible for queue handling.
#
IPC_START()
{
	local funcname=IPC_START
	local usage="$funcname(): usage: $funcname() tmpdir [concurrency]"

	local default_child_max=127
	local default_concurrency=1

	local child_lock
	local child_max
	local concurrency
	local fifo
	local tmpdir

	tmpdir=$1
	if [ -z "$tmpdir" ]; then
		warn EINVAL "$funcname(): null tmpdir"
		warnx "$usage"
		return 1
	fi
	if [ ! -d "$tmpdir" ]; then
		warn ENOTDIR "$funcname(): tmpdir: '$tmpdir'"
		warnx "$usage"
		return 1
	fi
	if [ ! -w "$tmpdir" ]; then
		warn EACCES "$funcname(): tmpdir: '$tmpdir'"
		return 1
	fi

	concurrency=$2
	if [ -z "$concurrency" ]; then
		concurrency=$default_concurrency
	fi
	if ! isdigit "$concurrency"; then
		warn EINVAL "$funcname(): concurrency: '$concurrency'"
		return 1
	fi
	if ! child_max=$(getconf CHILD_MAX); then
		warnx "$funcname(): failed to check getconf(1)"
		return 1
	fi
	if ! isdigit "$child_max"; then
		child_max=$default_child_max
	fi
	if [ $concurrency -gt $child_max ]; then
		warnx "$funcname(): limiting concurrency: '$concurrency' to CHILD_MAX: '$child_max'"
		concurrency=$child_max
	fi

	if [ -e "$tmpdir/info" ]; then
		warnx "$funcname(): stale tmpdir: '$tmpdir', already has info file"
		return 1
	fi

	fifo="$tmpdir/fifo"
	if ! mkfifo -- "$fifo"; then
		warnx "$funcname(): failed to populate tmpdir: '$tmpdir'"
		return 1
	fi

	child_lock="$tmpdir/child_lock"
	if ! touch "$child_lock"; then
		warnx "$funcname(): failed to set \$child_lock: '$child_lock'"
		return 1
	fi
	if ! chmod 0000 "$child_lock"; then
		warnx "$funcname(): failed to write-protect \$child_lock: '$child_lock'"
		return 1
	fi
	# drop the info file down
	cat > "$tmpdir/info" <<- EOT
		readonly IPC_FIFO=$fifo
		export IPC_FIFO
		readonly IPC_CHILD_LOCK=$child_lock
		export IPC_CHILD_LOCK
		readonly IPC_CONCURRENCY=$concurrency
		export IPC_CONCURRENCY
		readonly IPC_TEARDOWN=$tmpdir/teardown
		export IPC_TEARDOWN
	EOT

	. "$tmpdir/info"

	IPC_MASTER &

	return 0
}

#
# queue manager for IPC_CHILD invoked children.
#
# simplified state flow:
# - read fifo for incoming messages - sent by IPC_CHILD or
#   IPC_STOP
# - parse message to determine if a child wants to start running,
#   just started running; or if we're being told to shut down.
# - start pending children if there's headroom, wait for
#   others to finish if not
# - during shut down, create the teardown semaphore (checked for
#   by pending IPC_CHILD processes), wait for running children
#   to finish, and signal IPC_STOP to continue when we're done
#
IPC_MASTER()
{
	local funcname=IPC_MASTER

	local currently_running=0
	local currently_pending=0
	local currently_signaled=0
	local greatest_concurrency=0 
	local lifetime_ended_total=0
	local lifetime_started_total=0
	local message=INIT
	local pending_queue _pending_queue
	local pid pids
	local signal=CONT
	local teardown=0
	local var var2
	local wait_requestors _wait_requestors

	if ! pid=$(current_pid); then
		warnx "$funcname(): failed to get current PID"
		return 1
	fi
	# # debug 1 "$funcname(): [$message] -> '$pid'"

	while :; do

		message=READ
		# # debug 1 "$funcname(): [$message] beginning to read fifo"
		while read pid message; do

			while :; do

				# debug 1 "$funcname(): [READ] fifo: '$pid' -> [$message]"
				# debug 13 "$funcname(): [$message] logging message from '$pid'"
				# echo "$pid $message $funcname" >>"ipcdir/recvlog"

				case $message in
				"END "*[0-9]*)
					# end message includes return code of child, otherwise
					# unavailable b/c they were &'d..
					currently_running=$(( currently_running - 1 ))
					lifetime_ended_total=$(( lifetime_ended_total + 1 ))
					var=${message##* } # return value of the payload
					message=${message% $var}
					if [ $var -ne 0 ]; then
						warnx "$funcname(): [$message] nonzero return value '$var' from \$pid: '$pid'"
					fi
					;;
				PENDING)
					# at the pending stage, the PID is the same as IPC_CHILD's caller
					# so caring about it is not of significant value.
					currently_pending=$(( currently_pending + 1 ))
					;;
				START)
					currently_running=$(( currently_running + 1 ))
					if [ $currently_running -gt $greatest_concurrency ]; then
						# informational
						greatest_concurrency=$currently_running
					fi
					currently_signaled=$(( currently_signaled - 1 ))
					lifetime_started_total=$(( lifetime_started_total + 1 ))
					;;
				WAIT)
					# any children already in the $pending_queue have already
					# been sent their SIGCONT and already count toward the
					# running total, so they will be allowed to continue running
					# during teardown mode.
					signal=KILL
					teardown=1
					if ! >"$IPC_TEARDOWN"; then
						warnx "$funcname(): [$message] failed to set \$IPC_TEARDOWN file: '$IPC_TEARDOWN'"
					fi
					# debug 3 "$funcname(): [$message] adding \$pid '$pid' to \$wait_requestors '$wait_requestors'"
					# XXX check for dupes?
					if [ -z "$wait_requestors" ]; then
						wait_requestors=$pid
					else
						wait_requestors="$wait_requestors $pid"
					fi
					# debug 4 "$funcname(): [$message] \$wait_requestors is now '$wait_requestors', ensure addition \$pid: '$pid'"
					;;
				*)
					warnx "$funcname(): [$message] ERROR: unknown message"
					return 1
					;;
				esac

				message=WORK
				# debug 2 "$funcname(): [$message] looking for work"
				if [ $teardown -eq 1 ]; then
					# debug 0 "$funcname(): [$message] teardown mode confirmed"
					
					if [ $currently_running -gt 0 ]; then
						# still more running children to wait for
						# debug 2 "$funcname(): [$message] \$currently_running -gt 0, need to wait"
						break
					else
						# debug 2 "$funcname(): [$message] no running \$currently_running to wait for"
						:
					fi

					if [ $currently_signaled -gt 0 ]; then
						# debug 2 "$funcname(): [$message] \$currently_running -gt 0, need to wait"
						break
					else
						# debug 2 "$funcname(): [$message] no running \$currently_signaled to wait for"
						:
					fi

					# debug 2 "$funcname(): [$message] we appear to be finished with all outstanding work"
					# all done!
					break 3
				fi

				if [ $currently_running -ge $IPC_CONCURRENCY ]; then
					# debug 2 "$funcname(): [$message] at concurrency limit: '$IPC_CONCURRENCY', looping"
					break
				fi

				if [ $currently_pending -eq 0 ]; then
					break
				fi

				if [ -e "$IPC_CHILD_LOCK" ]; then
					# debug 37 "$funcname(): [$message] attempting to remove child lock: '$IPC_CHILD_LOCK'"
					if ! rm -f "$IPC_CHILD_LOCK"; then
						warnx "$funcname(): [$message] unable to remove pending child lock: '$IPC_CHILD_LOCK'"
						return 1
					fi
					currently_pending=$(( currently_pending - 1 ))
					currently_signaled=$(( currently_signaled + 1 ))
				else
					:
					# debug 2 "$funcname(): [$message] no child lock found"
				fi

				break
			done # while :;

			message=STATS
			# debug 10 "$funcname(): [$message] \$currently_running: '$currently_running'"
			# debug 12 "$funcname(): [$message] \$lifetime_started_total: '$lifetime_started_total'"
			# debug 12 "$funcname(): [$message] \$lifetime_ended_total: '$lifetime_ended_total'"

			message=READ
			# debug 1 "$funcname(): [$message] reading fifo"
			continue 

		done <"$IPC_FIFO"

		message=RECOVER
		# debug 7 "$funcname(): [$message] fell out of the loop because no pending fifo writes to read"
		# debug 10 "$funcname(): [$message] \$currently_running: '$currently_running'"
		# debug 12 "$funcname(): [$message] \$lifetime_started_total: '$lifetime_started_total'"
		# debug 12 "$funcname(): [$message] \$lifetime_ended_total: '$lifetime_ended_total'"
		
		if [ $currently_running -gt 0 ]; then
			# debug 7 "$funcname(): [$message] still children running"
			continue
		fi
		if [ $currently_signaled -gt 0 ]; then
			# debug 7 "$funcname(): [$message] still children signaled"
			continue
		fi
		if [ $lifetime_started_total -ne $lifetime_ended_total ]; then
			# debug 7 "$funcname(): [$mismatch] in lifetime total!?"
			continue
		fi

		continue

	done # while :; # top level

	message=COMPLETE
	if [ ! -z "$wait_requestors" ]; then
		# debug 2 "$funcname(): [$message] outstanding \$wait_requestors found"
		kill -CONT $wait_requestors
		# debug 2 "$funcname(): [$message] sent SIGCONT to \$wait_requestors: '$wait_requestors'"
	fi

	debug 1 "$funcname(): [$message] \$currently_running: '$currently_running'"
	debug 1 "$funcname(): [$message] \$greatest_concurrency: '$greatest_concurrency'"
	debug 1 "$funcname(): [$message] \$lifetime_started_total: '$lifetime_started_total'"
	debug 1 "$funcname(): [$message] \$lifetime_ended_total: '$lifetime_ended_total'"
	debug 1 "$funcname(): [$message] total victory, shutting down"
	return 0
}

#
# tells IPC_MASTER to enter shutdown mode
# blocks until IPC_MASTER signals everything's done.
#
IPC_STOP()
{
	local funcname=IPC_STOP
	local message=WAIT
	local pid

	# force a subshell so we can stop our own instantiation
	# without otherwise stopping the calling script.
	# don't background it; this function should block
	# until IPC_MASTER finishes teardown.
	
	(
		if ! pid=$(current_pid); then
			warnx "$funcname(): [$message] failed current_pid(), this child is worthless"
			return 1
		fi

		# debug 13 "$funcname(): [$message] -> '$pid'"
		# debug 12 "$funcname(): [$pid] [$message] sending message to fifo"
		if ! echo "$pid $message" >>"$IPC_FIFO"; then
			warnx "$funcname(): [$pid] [$message] failed sending message"
			return 1
		fi
		# debug 13 "$funcname(): [$pid] [$message] logging message"
		## echo "$pid $message $funcname" >>"ipcdir/sendlog"
		# debug 8 "$funcname(): [$pid] [$message] pausing myself with SIGSTOP"
		kill -STOP "$pid"
	);

	return 0
} 

#
# add this to the front of the command you want to parallelize.
#
# e.g.:
#
# -------------------------------
# for x in $(bunch of things); do
# 	something time consuming
# done
# -------------------------------
#
# becomes:
# -----------------------------------------
# for x in $(bunch of things); do
# 	IPC_CHILD something time consuming
# done
# -----------------------------------------
#
# it will block until IPC_MASTER has given it the go-ahead to begin work,
# at which point it will be backgrounded and the caller will continue on.
#
# since the "payload" (the original command) is executed backgrounded,
# its return value is not available to any callers/parents.  the return
# value will be communicated to IPC_MASTER over the fifo when the payload
# is finished.
#
IPC_CHILD()
{
	local funcname=IPC_CHILD
	local message pid
	local oldumask
	local retval
	local umask=0777

	# in the current implementation this is effectively the same as '$$' but
	# i'll burn another current_pid() run and we'll see if it hurts perf at all
	if ! pid=$(current_pid); then
		warnx "$funcname(): failed current_pid()"
		return 1
	fi
	if ! oldumask=$(umask); then
		warnx "$funcname(): [$message] failed to determine current umask"
		return 1
	fi
	message=PENDING
	# debug 14 "$funcname(): [$pid] [$message] 1: sending message to fifo"
	echo "$pid $message" >>"$IPC_FIFO"
	# debug 14 "$funcname(): [$pid] [$message] 2: unblocked from fifo"
	# debug 16 "$funcname(): [$pid] [$message] 3: adding message to log"
	# echo "$pid $message $funcname '$@'" >>"ipcdir/sendlog"
	if ! umask "$umask"; then
		warnx "$funcname(): [$message] failed to modify umask to '$umask'"
		return 1
	fi

	until 2>/dev/null >"$IPC_CHILD_LOCK"; do
		if [ -e "$IPC_TEARDOWN" ]; then
			# debug 2 "$funcname(): [$message] saw teardown semaphore, returning"
			return 1
		fi
	done
	# debug 13 "$funcname(): [$message] Y: free from child lock"
	if ! umask "$oldumask"; then
		warnx "$funcname(): [$message] failed to reset umask to \$oldumask: '$oldumask'"
		return 1
	fi
	message=START
	{
		if ! pid=$(current_pid); then
			warnx "$funcname(): failed current_pid(), child now worthless"
			return 1
		fi

		# debug 14 "$funcname(): [$pid] [$message]"
		while :; do

			# same block as above
			# debug 14 "$funcname(): [$pid] [$message] 1: sending message to fifo"
			case $message in
			END)
				echo "$pid $message $retval" >>"$IPC_FIFO"
				;;
			*)
				echo "$pid $message" >>"$IPC_FIFO"
				;;
			esac

			# debug 14 "$funcname(): [$pid] [$message] 2: unblocked from fifo"
			# debug 16 "$funcname(): [$pid] [$message] 3: adding message to log"
			# echo "$pid $message $funcname '$@'" >>"ipcdir/sendlog"

			case $message in
			START)
				# debug 11 "$funcname(): [$pid] [$message] 4: executing workload '$@'"
				if "$@"; then
					retval=$?
					# debug 11 "$funcname(): [$pid] [$message] 5: finished workload '$@'"
				else
					retval=$?
					warnx "$funcname(): [$pid] [$message]: workload failed: '$@'"
				fi
				message=END
				;;
			END)
				break
				;;
			*)
				warnx "$funcname(): [$pid] [$pid]: unknown \$message: '$message'"
				return 1
			esac
		done
	}&

	return 0
}

__script_lib_have_misc_ipc=1
