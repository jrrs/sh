case $__script_lib_have_misc_ipc in
1)
	return 0
	;;
esac

case $SCRIPT_LIB_ROOT in
"")
	_libroot=/usr/share/scriptlib
	;;
*)
	_libroot=$SCRIPT_LIB_ROOT
	;;
esac

. ${_libroot}/string/err
. ${_libroot}/string/isctype
. ${_libroot}/misc/current_pid

#
# usage: IPC_INIT tmpdir [concurrency]
#
# tmpdir - a writeable directory for IPC_* functions to perform work in.
# concurrency - maximum child concurrency for this IPC_INIT()'ed group
#	of processes.  valid range is 1 - CHILD_MAX.  default is 1. 
#	if CHILD_MAX is non numeric, such as 'undefined',
#	the max defaults to 127.
#
# returns 0 on success (IPC safe to use)
# returns 1 on error (IPC not safe to use)
#
# IPC_INIT() performs preliminaries and sanity checks, and populates
# tmpdir with the required IPC hierarchy.  it is recommended that tmpdir
# not be used by anything else.
#
# IPC_INIT() will drop a file in tmpdir named ``info'' and source it
# automatically, thus setting the following parameters:
#
# IPC_RUNNING_DIR, IPC_PENDING_DIR, IPC_ENDED_DIR
#	subdirs of the given tmpdir, used for internal queue management.
#	the various IPC_*() functions drop pid-named files into these
#	directories during run time.  external programs can approximate
#	the number of children running by looking at these directories.
# IPC_MASTER
#	the pid of the process who called IPC_INIT.
# IPC_CONCURRENCY
#	the value of concurrency given to IPC_INIT.
#
# WARNING WWAARRNNIINNGG WARNING
# ------- ------- -------
#
# do not invoke IPC_INIT from within a command substitution (eg:
# ``if ! err=$(IPC_INIT "$tmpdir"); then echo $err; fi'').
# as this will taint the value current_pid() returns for IPC_MASTER.
# naturally, it is perfectly fine to invoke it without a command substitution
# (eg: ``if ! IPC_INIT "$tmpdir"; then error cleanup; fi'').
# NOTE: this situation is precisely why IPC_INIT() doesn't do something
# useful like emit the full path to the info file, which would open the door
# for nice situations like "IPC_INIT $(mktemp -d)" or the eval commonly seen
# with ssh-agent(1).  c'est la vie.
#
IPC_INIT()
{
	local funcname=IPC_INIT
	local usage="$funcname(): usage: $funcname() tmpdir [concurrency]"

	local default_child_max=127
	local default_concurrency=1

	local child_max concurrency
	local current_pid
	local pending_dir running_dir ended_dir
	local tmpdir

	# enforce a predictable sorting order critical for pathnames
	# later
	LC_ALL=C

	# file globbing must be active
	case $- in
	*f*)
		warn EPERM "$funcname(): 'noglob' must be unset"
		return 1
	esac

	tmpdir=$1
	if [ -z "$tmpdir" ]; then
		warn EINVAL "$funcname(): null tmpdir"
		warnx "$usage"
		return 1
	fi
	if [ ! -d "$tmpdir" ]; then
		warn ENOTDIR "$funcname(): tmpdir: '$tmpdir'"
		warnx "$usage"
		return 1
	fi
	if [ ! -w "$tmpdir" ]; then
		warn EACCES "$funcname(): tmpdir: '$tmpdir'"
		return 1
	fi

	concurrency=$2
	if [ -z "$concurrency" ]; then
		concurrency=$default_concurrency
	fi
	if ! isdigit "$concurrency"; then
		warn EINVAL "$funcname(): concurrency: '$concurrency'"
		return 1
	fi
	if ! child_max=$(getconf CHILD_MAX); then
		warnx "$funcname(): failed to check getconf(1)"
		return 1
	fi
	if ! isdigit "$child_max"; then
		child_max=$default_child_max
	fi
	if [ $concurrency -gt $child_max ]; then
		warnx "$funcname(): limiting concurrency: '$concurrency' to CHILD_MAX: '$child_max'"
		concurrency=$child_max
	fi

	if ! current_pid=$(current_pid); then
		warnx "$funcname(): failed current_pid()"
		return 1
	fi

	if [ -e "$tmpdir/info" ]; then
		warnx "$funcname(): stale tmpdir: '$tmpdir', already has info file"
		return 1
	fi

	pending_dir="$tmpdir/pending"
	running_dir="$tmpdir/running"
	ended_dir="$tmpdir/ended"
	if ! mkdir -- "$pending_dir" "$running_dir" "$ended_dir"; then
		warnx "$funcname(): failed to populate tmpdir: '$tmpdir'"
		return 1
	fi

	# drop the info file down
	cat > "$tmpdir/info" <<- EOT
		readonly IPC_PENDING_DIR=$pending_dir
		readonly IPC_RUNNING_DIR=$running_dir
		readonly IPC_ENDED_DIR=$ended_dir
		readonly IPC_MASTER=$current_pid
		readonly IPC_CONCURRENCY=$concurrency
		export IPC_PENDING_DIR IPC_RUNNING_DIR IPC_ENDED_DIR
		export IPC_MASTER IPC_CONCURRENCY
	EOT

	case $BASH_VERSION in
	"")
		;;
	*)
		shopt -s expand_aliases
		;;
	esac

	. "$tmpdir/info"
	return 0
}

IPC2_START()
{
	local funcname=IPC2_START
	local usage="$funcname(): usage: $funcname() tmpdir [concurrency]"

	local default_child_max=127
	local default_concurrency=1

	local child_max concurrency
	local fifo
	local tmpdir

	tmpdir=$1
	if [ -z "$tmpdir" ]; then
		warn EINVAL "$funcname(): null tmpdir"
		warnx "$usage"
		return 1
	fi
	if [ ! -d "$tmpdir" ]; then
		warn ENOTDIR "$funcname(): tmpdir: '$tmpdir'"
		warnx "$usage"
		return 1
	fi
	if [ ! -w "$tmpdir" ]; then
		warn EACCES "$funcname(): tmpdir: '$tmpdir'"
		return 1
	fi

	concurrency=$2
	if [ -z "$concurrency" ]; then
		concurrency=$default_concurrency
	fi
	if ! isdigit "$concurrency"; then
		warn EINVAL "$funcname(): concurrency: '$concurrency'"
		return 1
	fi
	if ! child_max=$(getconf CHILD_MAX); then
		warnx "$funcname(): failed to check getconf(1)"
		return 1
	fi
	if ! isdigit "$child_max"; then
		child_max=$default_child_max
	fi
	if [ $concurrency -gt $child_max ]; then
		warnx "$funcname(): limiting concurrency: '$concurrency' to CHILD_MAX: '$child_max'"
		concurrency=$child_max
	fi

	if [ -e "$tmpdir/info" ]; then
		warnx "$funcname(): stale tmpdir: '$tmpdir', already has info file"
		return 1
	fi

	fifo="$tmpdir/fifo"
	if ! mkfifo -- "$fifo"; then
		warnx "$funcname(): failed to populate tmpdir: '$tmpdir'"
		return 1
	fi

	# drop the info file down
	cat > "$tmpdir/info" <<- EOT
		readonly IPC_FIFO=$fifo
		export IPC_FIFO
		readonly IPC_CONCURRENCY=$concurrency
		export IPC_CONCURRENCY
	EOT

	case $BASH_VERSION in
	"")
		;;
	*)
		shopt -s expand_aliases
		;;
	esac

	. "$tmpdir/info"

	IPC2_MASTER &

	return 0
}

IPC2_MASTER()
{
	local funcname=IPC2_MASTER
	local children=0
	local concurrency=$IPC_CONCURRENCY
	local ended_total=0
	local flag
	local flush
	local message
	local pendings pending_child _pendings
	local pid pids
	local signal=CONT
	local started_total=0
	local teardown=0
	local var
	local wait_requestors

	while :; do
		message=READ
		debug 10 "$funcname(): [$message] \$children: '$children'"
		debug 12 "$funcname(): [$message] \$started_total: '$started_total', \$ended_total: '$ended_total'"
		debug 1 "$funcname(): [$message] reading fifo"
		read pid message <"$fifo"
		debug 1 "$funcname(): [$message] -> '$pid'"
		debug 13 "$funcname(): [$message] logging message from '$pid'"
		echo "$pid $message $funcname" >>"ipcdir/recvlog"
		case $message in
		END)
			children=$(( children - 1 ))
			ended_total=$(( ended_total + 1 ))
			;;
		FINISH)
			# FINISH is the IPC2_END version of IPC2_CHILD's START.
			# it is used to indicate a SIGSTOP'd IPC2_END process
			# has received its SIGCONT.
			flag=0
			_pendings=""
			debug 3 "$funcname(): [$message] removing \$pid '$pid' from \$wait_requestors '$wait_requestors'"
			for var in $wait_requestors; do
				# remove the incoming PID from the wait requestors list
				# by making a new list populated by all the
				# pids in $pendings other than the one we have
				# in our hand now.
				case $var in
				$pid)
					flag=1
					;;
				*)
					case $_pendings in
					"")
						_pendings=$var
						;;
					*)
						_pendings="$_pendings $var"
						;;
					esac
					;;
				esac
			done
			if [ $flag -eq 0 ]; then
				# received a message for a non-pending PID.
				# XXX: ignore this?  fail?
				warnx "$funcname(): [$message] received message for non-pending \$pid: '$pid'"
				return 1
			fi
			wait_requestors="$_pendings"
			debug 3 "$funcname(): [$message] \$wait_requestors is now '$wait_requestors', ensure removal of \$pid: '$pid'"
			;;

		PENDING)
			# add PID to tail of pendings queue
			debug 3 "$funcname(): [$message] adding \$pid '$pid' to \$pendings '$pendings'"
			case $pendings in
			"")
				pendings=$pid
				;;
			*)
				pendings="$pendings $pid"
				;;
			esac
			debug 4 "$funcname(): [$message] \$pendings is now '$pendings', ensure addition of \$pid: '$pid'"
			;;
		START)
			# PID received our SIGCONT, remove from pending list
			flag=0
			_pendings=""
			debug 16 "$funcname(): [$message] removing \$pid '$pid' from \$pendings '$pendings'"
			for var in $pendings; do
				# remove the incoming PID from the pendings list
				# by making a new list populated by all the
				# pids in $pendings other than the one we have
				# in our hand now.
				case $var in
				$pid)
					flag=1
					;;
				*)
					case $_pendings in
					"")
						_pendings=$var
						;;
					*)
						_pendings="$_pendings $var"
						;;
					esac
					;;
				esac
			done
			if [ $flag -eq 0 ]; then
				# received a message message for a non-pending PID.
				# XXX: ignore this?  fail?
				warnx "$funcname(): [$message] received message for non-pending \$pid: '$pid'"
				return 1
			fi
			pendings="$_pendings"
			debug 4 "$funcname(): [$message] \$pendings is now '$pendings', ensure removal of \$pid: '$pid'"
			children=$(( children + 1 ))
			started_total=$(( started_total + 1 ))
			;;
		WAIT)
			# any newly seen "START"s on the fifo will be killed,
			# not stopped.
			signal=KILL
			teardown=1
			debug 3 "$funcname(): [$message] adding \$pid '$pid' to \$wait_requestors '$wait_requestors'"
			case $wait_requestors in
			"")
				wait_requestors=$pid
				;;
			*)
				wait_requestors="$wait_requestors $pid"
				;;
			esac
			debug 4 "$funcname(): [$message] \$wait_requestors is now '$wait_requestors', ensure addition \$pid: '$pid'"
			;;
		*)
			warnx "$funcname(): [$message] ERROR: unknown message"
			return 1
			;;
		esac

		message=WORK
		debug 2 "$funcname(): [$message] looking for work"
		if [ $teardown -eq 1 ]; then
			debug 0 "$funcname(): [$message] teardown mode confirmed"
			if [ ${#pendings} -gt 0 ]; then
				# kill all pending children and remove from pending
				kill -"$signal" $pendings
				debug 2 "$funcname(): [$message] sent '$signal' to pending children: '$pendings'"
				pendings=""
				debug 2 "$funcname(): [$message] cleared pending children list"
			else
				debug 2 "$funcname(): [$message] no pending children"
			fi
			
			if [ $children -gt 0 ]; then
				debug 2 "$funcname(): [$message] \$children -gt 0, need to wait"
				# still more running children to wait for
				continue
			else
				debug 2 "$funcname(): [$message] no running \$children to wait for"
			fi
			if [ ${#wait_requestors} -gt 0 ]; then
				debug 2 "$funcname(): [$message] outstanding \$wait_requestors found"
				kill -CONT $wait_requestors
				debug 2 "$funcname(): [$message] sent SIGCONT to \$wait_requestors: '$wait_requestors'"
				continue
			fi
			debug 2 "$funcname(): [$message] holy shit we are done! @&@ &@ &@& @& @&&@&@ @"
			# all done!
			break
		fi

		if [ $children -ge $concurrency ]; then
			debug 2 "$funcname(): [$message] at concurrency limit, looping"
			continue
		fi

		if [ ${#pendings} -eq 0 ]; then
			debug 2 "$funcname(): [$message] no pending children, looping"
			continue
		fi

		pid=${pendings%% *}
		debug 1 "$funcname(): [$message] found a pending child: '$pid', sending it '$signal'"
		kill -"$signal" $pid
		debug 2 "$funcname(): [$message] signal '$signal' sent to child '$pid'"
		# DO NOT remove a child from pendings here, that is done after
		# we see a 'START' from them, ensuring they got the signal to continue
		# XXX can i flush multiple here if i check to stay under concurrency?
		debug 3 "$funcname(): [$message] looping"
	done

	message=COMPLETE
	debug 18 "$funcname(): [$message] \$started_total: '$started_total', \$ended_total: '$ended_total'"
	debug 1 "$funcname(): [$message] holy shit total victory"
	return 0
}

IPC2_END()
{
	local funcname=IPC2_END
	local message=WAIT
	local pid

	# force a subshell so we can stop our own instantiation
	# without otherwise stopping the whole script
	(
		if ! pid=$(current_pid); then
			warnx "$funcname(): [$message] failed current_pid(), this child is worthless"
			return 1
		fi

		debug 13 "$funcname(): [$message] -> '$pid'"
		debug 12 "$funcname(): [$pid] [$message] sending message to fifo"
		if ! echo "$pid $message" >>"$IPC_FIFO"; then
			warnx "$funcname(): [$pid] [$message] failed sending message"
			return 1
		fi
		debug 13 "$funcname(): [$pid] [$message] logging message"
		echo "$pid $message $funcname" >>"ipcdir/sendlog"
		debug 8 "$funcname(): [$pid] [$message] pausing myself with SIGSTOP"
		kill -STOP "$pid"
		message=FINISH
		debug 8 "$funcname(): [$pid] [$message] RECEIVED SIGNAL TO CONTINUE"
		debug 12 "$funcname(): [$pid] [$message] sending message to fifo"
		if ! echo "$pid $message" >>"$IPC_FIFO"; then
			warnx "$funcname(): [$message] failed sending message"
			return 1
		fi
		debug 13 "$funcname(): [$pid] [$message] logging message"
		echo "$pid $message $funcname" >>"ipcdir/sendlog"
	);

	return 0
}

IPC2_CHILD()
{
	local funcname=IPC2_CHILD
	local pid message

	{

		if ! pid=$(current_pid); then
			warnx "$funcname(): failed current_pid(), this child is worthless"
			return 1
		fi
			
		message=PENDING
		while :; do

			debug 14 "$funcname(): [$pid] [$message] 1: sending message to fifo"
			echo "$pid $message" >>"$IPC_FIFO"
			debug 14 "$funcname(): [$pid] [$message] 2: unblocked from fifo"
			debug 16 "$funcname(): [$pid] [$message] 3: adding message to log"
			echo "$pid $message $funcname '$@'" >>"ipcdir/sendlog"

			case $message in
			PENDING)
				debug 19 "$funcname(): [$pid] [$message] 4: pausing myself with SIGSTOP"
				kill -STOP "$pid"
				debug 16 "$funcname(): [$pid] [$message] 5: RECEIVED SIGNAL TO CONTINUE"
				message=START
				;;
			START)
				# catch error
				debug 11 "$funcname(): [$pid] [$message] 4: executing workload '$@'"
				if eval "$@"; then
					debug 11 "$funcname(): [$pid] [$message] 5: finished workload '$@'"
				else
					warnx "$funcname(): [$pid] [$message]: workload failed: '$@'"
				fi
				message=END
				;;
			END)
				break
				;;
			esac
		done

	}&

	return 0
}

#
# usage: IPC_KILL
#
# individually checks $IPC_PENDING_DIR and $IPC_RUNNING_DIR for any pid
# files, sends a kill to everything it finds in there.
#
# TODO: refresh my memory on how the files move from one dir to another and
#       get unlinked when a process is totally done/reaped
#
# returns 0 on success
# returns 1 on error
#
IPC_KILL()
{
	local funcname=IPC_KILL
	local usage="$funcname(): usage: $funcname"

	local canary
	local dir
	local kill_list

	# child files are PIDs with an underscore prefix representing how
	# many generations deep the child is.
	local child
	
	while :; do
		canary=0

		for dir in $IPC_PENDING_DIR $IPC_RUNNING_DIR; do

			kill_list=

			if [ -z "$dir" ]; then
				warnx "$funcname(): null directory given"
				return 1
			fi
			if [ ! -d "$dir" ]; then
				warn ENOTDIR "$funcname(): '$dir'"
				continue
			fi

			for child in "$dir/"*; do
				case $child in
				*"*")
					# no files in the dir to glob
					debug 2 "$funcname(): found a bare *: '$child'; empty '$dir'?"
					continue 2
					;;
				esac
				child=${child##*/} # basename

				# chop off leading child depth markers
				# for now, we can eliminate them entirely, but eventually
				# we'll have to consider their length to translate that to
				# depth away from parent.
				case $child in
				_*)
					child=${child##*_}
					debug 2 "$funcname(): chopped '_' off \$child: '$child'"
					;;
				esac

				case $child in
				$IPC_MASTER)
					warnx "$funcname(): \$IPC_MASTER seen in '$dir'"
					# XXX: should not happen?
					return 1
					;;
				esac

				# this is a number test instead of a -z against the string
				# as the latter is slower as the length of the string grows
				case ${#kill_list} in
				0)
					kill_list=$child
					;;
				*)
					# prepending to the list ensures children with
					# highest generational depth are first
					kill_list="$child $kill_list"
					;;
				esac
				debug 2 "$funcname(): \$kill_list: '$kill_list'"
			done

			if [ -z "$kill_list" ]; then
				continue
			fi
			canary=$(( canary | 1 ))
			kill $kill_list || true
		done

		if [ $canary -gt 0 ]; then
			# work was done in at least one of the pending/running dirs
			continue
		fi
		break
	done

	return 0
}

#
# usage: IPC_FORK commandline to fork
#
# if we are not at the limit of concurrency, forks a new child.
# otherwise, it will manage the currently forked children until
# some headroom appears, at which point the new child will be forked.
#
# returns 0 on success
# returns 1 on error
#
# IPC_FORK calls one of two helper functions based on whether
# or not it is being run by the $IPC_MASTER.  reason for this
# distinction is that process oversight IPC_FORK is also responsible for sending
# the process oversight
#
# note, if you are running IPC_FORK from within forked children,
# you *will* deadlock if concurrency is less than the maximum
# number of potentially unstarted pending child-forked children
# out there.  eg, *really* don't leave it at the defaut of '1' in
# this case.
#
# XXX WARNING:
#
# backgrounding children from children is currently VERY DANGEROUS.
# it *functions*, but you need to specify a concurrency WAY HIGHER
# than you otherwise think you should.  it is strongly recommended
# to NOT background children from children at the present time
#
IPC_FORK()
{
	local funcname=IPC_FORK
	local p x
	if [ -z "$IPC_MASTER" ]; then
		warnx "$funcname(): \$IPC_MASTER is null"
		return 1
	fi
	if ! p=$(current_pid "$IPC_MASTER"); then
		warnx "$funcname(): failed current_pid()"
		return 1
	fi
	debug 1 "$funcname(): \$p is: '$p'"
	case $p in
	$IPC_MASTER)
		debug 2 "$funcname(): shall fork _ipc_master"
		if ! _ipc_master "$*"; then
			warnx "$funcname(): failed _ipc_master()"
			return 1
		fi
		;;
	*)
		x=0
		while :; do
			case $p in
			_*)
				p=${p#_}
				x=$(( $x + 1 ))
				;;
			*)
				break
				;;
			esac
		done
		debug 1 "$funcname(): \$p: '$p'; shall fork _ipc_child $x"
		if ! _ipc_child "$x" "$*"; then
			warnx "$funcname(): failed _ipc_child()"
			return 1
		fi
		;;
	esac
	return 0
}

#
# usage: IPC_FLUSH
#
# loops through _ipc_start and _ipc_end until they both did nothing $max times.
#
# $max is 16 by default, based on seeing things work just fine at 8 and then
# doubling it for safety's sake
#
# XXX check to see if current_pid is actually $IPC_MASTER
#
IPC_FLUSH()
{
	local funcname=IPC_FLUSH
	local e r s t	# ending, running, started, total
	local i		# current iteration of t being -eq 0
	local max=8
	while :; do
		if ! e=$(_ipc_end); then
			warnx "$funcname(): failed _ipc_end"
			return 1
		fi
		if ! s=$(_ipc_start); then
			warnx "$funcname(): failed _ipc_start"
			return 1
		fi
		if ! r=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR"
			return 1
		fi
		t=$(( $s + $e + $r ))
		if [ $t -eq 0 ]; then
			i=$(( $i + 1 ))
		else
			i=0
		fi
		if [ $i -gt $max ]; then
			warnx "$funcname(): \$i -gt \$max"
			break
		fi
	done
	return 0
}

#
# usage: IPC_START
#
# use at the start of all child processes/functions which are IPC_FORK()'d.
#
# for example:
#
# 	somefunc()
# 	{
# 		local var=b
# 		code
# 		return 0
#	}
#
# becomes:
#
# 	somefunc()
# 	{
# 		IPC_START
# 		local var=b
# 		code
# 		IPC_RETURN 0
# 	{
#
# creates local variables to contain pid, creates trap handler
# for use in signalling, and drops the current pid into the $IPC_PENDING_DIR.
# upon receipt of start signal, moves current pid from $IPC_PENDING_DIR to
# $IPC_RUNNING_DIR.
#
alias IPC_START='
	if [ -z "$IPC_MASTER" ]; then
		warnx "$funcname():[IPC_START] \$IPC_MASTER null"
		warnx "$funcname():[IPC_START] concurrency control disabled"
	else
		local _ipc_pid _ipc_loop_stop=0
		trap '\''trap - CONT; _ipc_loop_stop=1'\'' CONT
		if ! _ipc_pid=$(current_pid "$IPC_MASTER"); then
			warnx "$funcname()[IPC_START]: failed current_pid()"
			return 1
		fi
		if [ ! -d "$IPC_PENDING_DIR" ]; then
			warnx "$funcname()[IPC_START][$_ipc_pid]: pending dir not exist or not a directory"
			return 1
		fi
		if [ ! -d "$IPC_RUNNING_DIR" ]; then
			warnx "$funcname()[IPC_START][$_ipc_pid]: running dir not exist or not a directory"
			return 1
		fi
		> "$IPC_PENDING_DIR/$_ipc_pid"
		while [ $_ipc_loop_stop -eq 0 ]; do
			sleep 0.1
		done
		# strip off leading underscores during mv(1)
		mv -- "$IPC_PENDING_DIR/$_ipc_pid" "$IPC_RUNNING_DIR/${_ipc_pid##*_}"
	fi'

#
# usage: IPC_RETURN [retval]
#
# use in place of 'return' (for all instances!) inside all child processes/
# functions which are IPC_FORK()'d.
#
# see IPC_START above for an example usage.
#
# adds the current pid to the $IPC_ENDED_DIR and then returns whatever value
# was specfied.  if no value specified, the effect is the same as invoking
# a regular 'return' without args.
#
alias IPC_RETURN='
	if [ -z "$IPC_MASTER" ]; then
		warnx "$funcname():[IPC_RETURN][$_ipc_pid] \$IPC_MASTER null"
		warnx "$funcname():[IPC_RETURN][$_ipc_pid] concurrency control disabled"
		return 1
	else
		if [ ! -d "$IPC_ENDED_DIR" ]; then
			warnx "$funcname():[IPC_RETURN][$_ipc_pid] no \$IPC_ENDED_DIR"
			return 1
		fi
		> "$IPC_ENDED_DIR/$_ipc_pid"
	fi
	return' # leave the closing apostrophe on this line

#
# _ipc_getnumchildren dir
#
# emits the number of children in $dir.
#
# returns 0 on successful check
# returns 1 on error
#
_ipc_getnumchildren()
{
	local funcname=_ipc_getnumchildren
	local f n=0
	local usage="$funcname(): usage: $funcname dir"
	if [ -z "$1" ]; then
		warn EINVAL
		warnx "$usage"
		return 1
	fi
	for f in "$1"/*; do
		n=$(( $n + 1 ))
	done
	case $f in
	*"*")
		echo 0
		;;
	*)
		echo $n
		;;
	esac
	return 0
}

#
# _ipc_clean_ended
#
# emits the number of children it cleaned up (may be 0) and returns 0
# returns 1 on error
#
_ipc_clean_ended()
{
	local funcname=_ipc_clean_ended
	local usage="$funcname(): usage: $funcname"
	local ef rf rm
	local x=0
	for ef in $IPC_ENDED_DIR/*; do
		case $ef in
		"$IPC_ENDED_DIR/*")
			break
			;;
		esac
		rf=$IPC_RUNNING_DIR/${ef##*/}
		if [ ! -f "$rf" ]; then
			warnx "$funcname() \${ef##*/}: '${ef##*/}' exists in ended but not running"
			return 1
		fi
		case ${#rm} in
		0)
			rm="$ef $rf"
			;;
		*)
			rm="$ef $rf $rm"
			;;
		esac
		debug 2 "$funcname(): \$rm: '$rm'"
		x=$(( $x + 1 ))
	done
	if [ $x -gt 0 ]; then
		if ! rm -- $rm; then
			return 1
		fi
	fi
	echo $x
	return 0
}

#
# _ipc_start_n_children n
#
# starts up to $n children from the $IPC_PENDING_DIR by sending them all SIGCONT
# to break them out of IPC_START.
#
# returns 1 on error
# returns 0 otherwise and emits # of children it sent SIGCONT to
#
# XXX really should take ARG_MAX into account
#
_ipc_start_n_children()
{
	local funcname=_ipc_start_n_children
	local usage="$funcname(): usage: $funcname n"
	local n=$1 c s=0 k s
	local string
	case $n in
	"" | *[!0-9]*)
		warnx "$funcname(): non numeric \$n"
		warnx "$usage"
		return 1
		;;
	esac

	#
	# we will be getting a listing of the directory
	# in an order that, while correct, is the inverse
	# of what we want.  due to the underscore prefixes,
	# the following list will occur in closest-child-
	# first" order.  we want to SIGCONT the children in
	# farthest-child-first.  we also want to SIGCONT
	# only the $n children we were told.  the cost of
	# calling to the userland is too great here, so it is
	# much cheaper to take the output and use a param to
	# flip its order than it is to do a single $(ls -r).
	#
	for c in "$IPC_PENDING_DIR/"*; do
		case $c in
		*"*")
			echo 0
			return 0
			;;
		esac

		# chop off leading child depth markers
		c=${c#$IPC_PENDING_DIR/}
		while :; do
			case $c in
			_*)
				c=${c##*_}
				continue
				;;
			esac

			break
		done

		case $c in
			$IPC_MASTER)
			warnx "$funcname(): \$IPC_MASTER seen in \$IPC_PENDING_DIR"
			return 1
			;;
		esac

		# we can afford to be messy and not
		# worry about the extra space that
		# blindly doing string="$c $string" 
		# earns on the first time around.
		string="$c $string"

	done

	# build up kill string up to $n items
	for c in $string; do
		if [ $s -ge $n ]; then
			break
		fi

		case ${#k} in
		0)
			k=$c
			;;
		*)
			k="$c $k"
			;;
		esac

		s=$(( $s + 1 ))
	done

	if [ $s -gt 0 ]; then
		if ! kill -CONT $k; then
			return 1
		fi
	fi
	echo $s
	return 0
}

#
# _ipc_start 
#
# runs _ipc_start_n_children() with an argument that is the lesser of either
# the number pending children or the difference between $IPC_CONCURRENCY and
# what it finds to be running 
#
# returns 1 on error
# returns 0 on success and emits number of children it thinks it
#           started.  emits '-1' to indicate that we are already
#	    at max IPC_CONCURRENCY and no attempt to start children was made.
#
_ipc_start()
{
	local funcname=_ipc_start
	local r p headroom s
	if ! r=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
		warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR: '$IPC_RUNNING_DIR'"
		return 1
	fi
	headroom=$(( $IPC_CONCURRENCY - $r ))
	#
	# if we are at max already, indicate that to the caller
	#
	if [ $headroom -le 0 ]; then
		echo -1
		return 0
	fi
	if ! p=$(_ipc_getnumchildren "$IPC_PENDING_DIR"); then
		warnx "$funcname(): failed _ipc_getnumchildren \$IPC_PENDING_DIR: '$IPC_PENDING_DIR'"
		return 1
	fi
	if [ $p -eq 0 ]; then
		# no pending children
		echo 0
		return 0
	fi
	# don't start more than $headroom
	if [ $p -gt $headroom ]; then
		p=$headroom
	fi
	if ! s=$(_ipc_start_n_children "$p"); then
		warnx "$funcname(): failed _ipc_start_n_children() '$p'"
		return 1
	fi
	echo $s
	return 0
}

#
# usage: _ipc_end
#
# runs _ipc_clean_ended() until it reports no children
# were cleaned, then emits the total number of children it cleaned up.
#
_ipc_end()
{
	local funcname=_ipc_end
	local t=0 x
	#
	# this loop will run until there are no children in the
	# $IPC_ENDED_DIR.  at the end of the loop, '$ended' will be
	# however many children we cleaned up during looping
	#
	while :; do
		if ! x=$(_ipc_clean_ended); then
			warnx "$funcname(): failed _ipc_clean_ended()"
			return 1
		fi
		if [ $x -eq 0 ]; then
			break
		fi
		t=$(( $t + $x ))
	done
	echo $t
	return 0
}

#
# usage: _ipc_master
#
# invoked by IPC_FORK if IPC_FORK was called from the $IPC_MASTER pid.
#
_ipc_master()
{
	local funcname=_ipc_master
	local r1 r2 r c t
	while :; do
		debug 2 "$funcname(): trying _ipc_end()"
		if ! c=$(_ipc_end); then
			warnx "$funcname(): failed _ipc_end()"
			return 1
		fi
		r1=0
		if ! r1=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR"
			return 1
		fi
		if ! c=$(_ipc_start); then
			warnx "$funcname(): failed _ipc_start"
			return 1
		fi
		if [ $c -eq -1 ]; then
			debug 2 "$funcname(): already at max concurrency"
			continue
		fi
		if [ $c -ge $IPC_CONCURRENCY ]; then
			# we just think we started $IPC_CONCURRENCY's worth of
			# children, so chill out
			debug 2 "$funcname(): just started \$IPC_CONCURRENCY's worth"
			continue
		fi
		r2=0
		if ! r2=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR"
			return 1
		fi
		if [ $r1 -gt $r2 ]; then
			r=$r1
		else
			r=$r2
		fi
		t=$(( $c + $r ))

		# if we are at maximum, we need to
		# loop back to the top and look for more ended children
		if [ $t -ge $IPC_CONCURRENCY ]; then
			continue
		fi
		debug 2 "$funcname(): eval: '$*'"
		eval "$*" &
		break
	done
	return 0
}

#
# usage: _ipc_child current_pid
#
# invoked by IPC_FORK if IPC_FORK was not called from the $IPC_MASTER pid.
#
# inspects $IPC_RUNNING_DIR and $IPC_PENDING_DIR, compares against
# $IPC_CONCURRENCY; sleeps if too many running, otherwise evals the
# child with '&'.
#
# doesn't send any signals 
#
# RETURN
# 0 - evaled a child
# 1 - failed _ipc_getnumchildren()
#
_ipc_child()
{
	local funcname=_ipc_child
	local depth
	local r p headroom
	depth=$1
	shift
	while :; do
		if ! r=$(_ipc_getnumchildren "$IPC_RUNNING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_RUNNING_DIR"
			return 1
		fi
		if ! p=$(_ipc_getnumchildren "$IPC_PENDING_DIR"); then
			warnx "$funcname(): failed _ipc_getnumchildren \$IPC_PENDING_DIR"
			return 1
		fi
		headroom=$(( $IPC_CONCURRENCY + $depth - $r - $p ))
		debug 2 "$funcname(): \$headroom: '$headroom'"
		if [ $headroom -le 0 ]; then
			# penalty sleep, not allowed to start yet
			sleep 0.1
			continue
		fi
		eval "$*" &
		break
	done
	return 0
}

__script_lib_have_misc_ipc=1
